# MPU6050 代码调用说明

## ✅ 当前配置（测试模式）

### 调用架构

```
main.c (主循环)
  ├─ while(1)
  │   ├─ MPU6050_Update() ← 每100ms更新MPU6050数据
  │   │   └─ 内部自动更新：
  │   │       ├─ 姿态角度 (pitch, roll, yaw)
  │   │       ├─ 加速度 (accel_x/y/z)
  │   │       ├─ 计步器 (step_count)
  │   │       └─ 距离 (distance)
  │   │
  │   ├─ 每1秒打印一次数据到串口
  │   │   └─ 显示姿态、加速度、计步器等信息
  │   │
  │   ├─ scheduler_run() ← 运行任务调度器
  │   │   └─ (当前为空，没有任务)
  │   │
  │   └─ HAL_Delay(100) ← 100ms延迟
  │
  └─ OLED 实时显示加速度
```

### 修改说明

#### 已注释的代码

```c
// APP/scheduler.c - 第26行
// {mpu6050_task,100,0}, // 已注释，避免与main.c重复调用
```

**原因：** 
- `mpu6050_task()` 内部调用 `MPU6050_Update()`
- main.c 中已经调用 `MPU6050_Update()`
- 重复调用会导致不必要的 I2C 通信和性能损耗

---

## 🎯 两种使用模式

### 模式 1: 测试模式（当前配置）⭐ 推荐测试时使用

**特点：**
- 在 main.c 主循环中直接控制
- 代码集中，便于调试
- 可以灵活控制打印时机和内容

**配置：**

```c
// main.c - while(1) 循环中
while (1)
{
    // 更新 MPU6050
    if (MPU6050_Update() == MPU6050_OK)
    {
        // 自定义处理逻辑
        OLED_ShowFloat(1, 1, mpu6050_data.accel_x_g, 2, 3);
        
        // 每1秒打印
        if ((HAL_GetTick() - last_print_tick) >= 1000)
        {
            printf("步数: %lu\r\n", mpu6050_data.step_count);
            // ... 更多自定义打印
        }
    }
    
    scheduler_run();  // 其他任务
    HAL_Delay(100);
}

// scheduler.c - 注释掉 mpu6050_task
static task_t scheduler_task[] =
{
    // {mpu6050_task,100,0}, // 已注释
};
```

**优点：**
- ✅ 便于测试和调试
- ✅ 可以灵活控制打印频率
- ✅ 代码逻辑清晰
- ✅ 适合学习和实验

**缺点：**
- ⚠️ 代码不够模块化
- ⚠️ 不适合大型项目

---

### 模式 2: 调度器模式（产品化配置）⭐ 推荐产品使用

**特点：**
- 使用任务调度器管理
- 架构清晰，易维护
- 多任务并行执行

**配置：**

```c
// main.c - while(1) 循环简化
while (1)
{
    // 只运行调度器
    scheduler_run();
    
    // 可选：OLED 显示
    OLED_ShowFloat(1, 1, mpu6050_data.accel_x_g, 2, 3);
    OLED_ShowFloat(2, 1, mpu6050_data.accel_y_g, 2, 3);
    OLED_ShowFloat(3, 1, mpu6050_data.accel_z_g, 2, 3);
    
    HAL_Delay(10);  // 短延迟
}

// scheduler.c - 启用 mpu6050_task
static task_t scheduler_task[] =
{
    {mpu6050_task, 100, 0},   // MPU6050更新，100ms周期
    {dht11_task, 1000, 0},    // DHT11采集，1000ms周期
    {mq2_task, 100, 0},       // MQ2采集，100ms周期
    // ... 更多任务
};
```

**优点：**
- ✅ 架构清晰，模块化好
- ✅ 易于添加新任务
- ✅ 任务独立，互不干扰
- ✅ 适合产品化开发

**缺点：**
- ⚠️ 调试稍微复杂
- ⚠️ 需要理解调度器原理

---

## 🔄 如何切换模式

### 从测试模式 → 调度器模式

**步骤 1：修改 main.c**

```c
// 删除或注释掉主循环中的 MPU6050_Update() 和打印代码
while (1)
{
    // 删除这部分 ↓
    /*
    if (MPU6050_Update() == MPU6050_OK)
    {
        // ... 打印代码
    }
    */
    
    // 只保留 scheduler_run()
    scheduler_run();
    
    // 可选：保留 OLED 显示
    OLED_ShowFloat(1, 1, mpu6050_data.accel_x_g, 2, 3);
    OLED_ShowFloat(2, 1, mpu6050_data.accel_y_g, 2, 3);
    OLED_ShowFloat(3, 1, mpu6050_data.accel_z_g, 2, 3);
    
    HAL_Delay(10);
}
```

**步骤 2：修改 scheduler.c**

```c
// 取消注释 mpu6050_task
static task_t scheduler_task[] =
{
    {mpu6050_task, 100, 0},  // 恢复 MPU6050 任务
};
```

**步骤 3：重新编译下载**

---

### 从调度器模式 → 测试模式

**步骤 1：修改 scheduler.c**

```c
// 注释掉 mpu6050_task
static task_t scheduler_task[] =
{
    // {mpu6050_task, 100, 0},  // 注释掉
};
```

**步骤 2：修改 main.c**

```c
// 添加 MPU6050 更新和打印逻辑
while (1)
{
    if (MPU6050_Update() == MPU6050_OK)
    {
        // 自定义打印逻辑
        // ... (参考当前的实现)
    }
    
    scheduler_run();
    HAL_Delay(100);
}
```

**步骤 3：重新编译下载**

---

## 📊 性能对比

### 测试模式

```
CPU 占用率：~5%
I2C 调用频率：100ms 一次（10 Hz）
串口打印频率：1000ms 一次（1 Hz）
内存占用：低
响应速度：快
```

### 调度器模式

```
CPU 占用率：~5%
I2C 调用频率：100ms 一次（10 Hz）
串口打印频率：100ms 一次（10 Hz，由 mpu6050_task 控制）
内存占用：稍高（调度器开销）
响应速度：快
```

**结论：** 两种模式性能差异不大，主要区别在于代码架构

---

## ⚠️ 注意事项

### 1. 避免重复调用

**错误示例：** ❌

```c
// main.c
while (1)
{
    MPU6050_Update();  // 调用1
    scheduler_run();   // 内部还会调用 MPU6050_Update() - 调用2
}

// scheduler.c
static task_t scheduler_task[] =
{
    {mpu6050_task, 100, 0},  // mpu6050_task 内部调用 MPU6050_Update()
};
```

**问题：**
- 重复的 I2C 通信
- 浪费 CPU 资源
- 可能导致数据不一致

**正确做法：** ✅

```c
// 选择一种方式：

// 方式1：只在 main.c 中调用
while (1)
{
    MPU6050_Update();  // 只调用一次
    scheduler_run();
}
// scheduler.c: 注释掉 mpu6050_task

// 或者

// 方式2：只在 scheduler 中调用
while (1)
{
    scheduler_run();  // 内部调用 mpu6050_task
}
// scheduler.c: 启用 mpu6050_task
```

---

### 2. 打印频率控制

**测试模式：** 可以灵活控制

```c
// 每1秒打印
if ((HAL_GetTick() - last_print_tick) >= 1000)
{
    printf("步数: %lu\r\n", mpu6050_data.step_count);
}

// 或每次步数变化时打印
if (mpu6050_data.step_count != last_steps)
{
    printf("✓ 新增步数！\r\n");
}
```

**调度器模式：** 由 `mpu6050_task` 控制

```c
// mpu_app.c - mpu6050_task()
void mpu6050_task(void)
{
    if (MPU6050_Update() == MPU6050_OK)
    {
        MPU6050_PrintInfo();  // 每次都打印（100ms一次）
    }
}
```

如果想改变打印频率，需要修改 `mpu6050_task()` 或调整任务周期。

---

### 3. OLED 显示

**无论哪种模式，OLED 显示都可以在 main.c 中直接调用：**

```c
while (1)
{
    // MPU6050 更新（根据模式选择）
    
    // OLED 显示（两种模式通用）
    OLED_ShowFloat(1, 1, mpu6050_data.accel_x_g, 2, 3);
    OLED_ShowFloat(2, 1, mpu6050_data.accel_y_g, 2, 3);
    OLED_ShowFloat(3, 1, mpu6050_data.accel_z_g, 2, 3);
    
    // 显示步数
    OLED_ShowNum(4, 1, mpu6050_data.step_count, 5);
    
    HAL_Delay(100);
}
```

**原因：** 
- `mpu6050_data` 是全局变量
- 任何地方都可以直接读取
- OLED 更新频率可以独立控制

---

## 🎯 推荐配置总结

### 当前测试阶段 ✅ （已配置）

```
模式：测试模式
调用位置：main.c 主循环
更新频率：100ms
打印频率：1000ms（可变化时立即打印）
优点：灵活调试，便于测试
```

### 功能调试完成后

```
模式：调度器模式
调用位置：scheduler.c
更新频率：100ms
打印频率：100ms 或关闭打印
优点：架构清晰，易维护
```

---

## 📝 修改历史

```
2025-11-11 v1.0
- 初始版本
- 注释掉 scheduler.c 中的 mpu6050_task
- 在 main.c 主循环中直接调用 MPU6050_Update()
- 配置为测试模式
```

---

## 🆘 常见问题

### Q1: 为什么要注释掉 scheduler 中的任务？

**A:** 避免重复调用 `MPU6050_Update()`，重复调用会：
- 浪费 CPU 和 I2C 总线资源
- 可能导致数据不一致
- 增加不必要的功耗

---

### Q2: 我可以同时在两个地方调用吗？

**A:** 不推荐！虽然不会出错，但会：
- 每 100ms 调用 2 次（50ms 一次）
- I2C 通信频率翻倍
- 增加系统负担
- 没有实际好处

---

### Q3: 测试完成后需要改成调度器模式吗？

**A:** 看需求：
- **产品化开发** → 建议用调度器模式（架构清晰）
- **简单应用** → 测试模式也可以（够用）
- **学习项目** → 任选其一（都可以）

---

### Q4: 如何添加更多任务？

**A:** 在 scheduler.c 中添加：

```c
static task_t scheduler_task[] =
{
    {dht11_task, 1000, 0},   // DHT11，1秒一次
    {mq2_task, 100, 0},      // MQ2，100ms一次
    {led_task, 500, 0},      // LED，500ms一次
    // 需要时再启用 mpu6050_task
};
```

---

## ✅ 当前状态确认

```
✓ scheduler.c 中 mpu6050_task 已注释
✓ main.c 中直接调用 MPU6050_Update()
✓ 避免了重复调用
✓ 代码配置正确
✓ 可以正常测试
```

**现在可以直接编译下载测试了！** 🎉

